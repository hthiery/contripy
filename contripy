#!/usr/bin/env python3

import argparse
import json
import os
import subprocess
import sys
import yaml

from datetime import datetime
from dotenv import load_dotenv
from envyaml import EnvYAML
from python_graphql_client import GraphqlClient

REPOS_DIR = 'repos'


class Project(object):
    def __init__(self, name, cfg):
        self.name = name
        self.url = cfg['url']
        self.giturl = cfg['giturl']
        self.gitweburl = cfg['gitweburl']
        self.description = cfg['description']

        if 'parser' in cfg:
            self.parser = cfg['parser']
        else:
            self.parser = 'git'

        if 'skip-users' in cfg:
            self.skip_users = cfg['skip-users']
        else:
            self.skip_users = None

        if 'only-users' in cfg:
            self.only_users = cfg['only-users']
        else:
            self.only_users = None

        if 'branch' in cfg:
            self.branch = cfg['branch']
        else:
            self.branch = 'master'

        if self.giturl.startswith("https://github.com/"):
            repo = self.giturl.split("/")[-1]
            owner = self.giturl[len("https://github.com/"):-(len(repo)+1)]
            self.repo = {
                "name": repo,
                "owner": owner
            }


class Author(object):
    def __init__(self, name, cfg):
        self.name = name
        self.emails = cfg['emails']
        self.projects = {}

    def _add_contributions(self, project, commits, contribution):
        commits = sorted(commits, key=lambda k: k['date'], reverse=True)
        if project not in self.projects:
            self.projects[project] = {}
        self.projects[project][contribution] = commits

    def add_authored_contributions(self, project, commits):
        """Add authored commits."""
        self._add_contributions(project, commits, 'authored')

    def add_other_contributions(self, project, commits):
        """Add other contributions."""
        self._add_contributions(project, commits, 'others')

class ContributionParser:
    def __init__(self, project, args):
        self.project = project
        self.args = args

    def get_other_contributions(self, author):
        return []

    def get_authored_contributions(self, author):
        return []

    def update_project(self):
        pass

    def create_commit_link(self, commit):
        commit['link'] = self.project.gitweburl.replace('%COMMIT-ID%', commit['id'])

class GitContributionParser(ContributionParser):
    def __init__(self, project, args):
        super().__init__(project, args)
        self._get_repo(REPOS_DIR)

    def get_other_contributions(self, author):
        commits = list()

        cmd = [
            'git',
            'log',
            '--date=short',
            '--after={}'.format(self.args.period_start),
            '--until={}'.format(self.args.period_end),
            '--pretty=format:id=%H##date=%ad##author=%an##email=%ae##subject=%s',
            '--regexp-ignore-case',
        ]

        # The contribution type. Don't care about lower/upper case.
        # case is ignored (-i/--regexp-ignore-case option)
        contributions = [
            "signed-off-by",
            "reported-by",
            "tested-by",
            "suggested-by",
            "reviewed-by",
            "co-developed-by",
            "acked-by"
        ]
        for c in contributions:
            for email in author.emails:
                cmd.append('--grep')
                cmd.append('{}:.*{}'.format(c, email))

        output = subprocess.check_output(cmd, cwd=self.repodir)
        for line in output.splitlines():
            try:
                commit = self._get_commit_from_line(line)

                # skip if author of commit is same as user (author)
                if commit['email'] in author.emails:
                    continue

                commits.append(commit)

            except ValueError:
                print('ignore', line)

        for commit in commits:
            self.create_commit_link(commit)

        return commits

    def get_authored_contributions(self, author):
        commits = list()

        cmd = [
            'git',
            'log',
            '--date=short',
            '--pretty=format:id=%H##date=%ad##author=%an##email=%ae##subject=%s',
            '--after={}'.format(self.args.period_start),
            '--until={}'.format(self.args.period_end),
            '--author={}'.format(author.name),
            ]
        output = subprocess.check_output(cmd, cwd=self.repodir)
        for line in output.splitlines():
            try:
                commit = self._get_commit_from_line(line)
                if commit['email'].lower() not in [a.lower() for a in author.emails]:
                    continue
                commits.append(commit)
            except ValueError:
                print('ignore', line)

        for commit in commits:
            self.create_commit_link(commit)

        return commits

    def _create_repos_dir(self):
        if not os.path.exists(REPOS_DIR):
            os.makedirs(REPOS_DIR)

    def _get_repo(self, repos_dir):
        self._create_repos_dir()
        self.repodir = os.path.join(REPOS_DIR, self.project.name)
        print(self.repodir)

        try:
            cmd = [
                'git',
                'clone',
                self.project.giturl,
                self.project.name
                ]
            o = subprocess.check_output(cmd, cwd=REPOS_DIR)
        except subprocess.CalledProcessError:
            # assume we already cloned and now we can fetch/pull
            cmd = [
                'git',
                'pull'
                ]
            o = subprocess.check_output(cmd, cwd=self.repodir)

    #    try:
    #        cmd = [
    #             'git',
    #             'checkout',
    #             '{}'.format(project.branch)
    #             ]
    #        o = subprocess.check_output(cmd, cwd=project_repo_dir)
    #    except subprocess.CalledProcessError:
    #        print('cannot switch to branch "{}"'.format(project.branch))
    #        sys.exit(1)

    def _get_commit_from_line(self, line):
        commit = {}
        values = line.decode().split('##')
        for value in values:
            s = value.split('=')
            commit[s[0]] = s[1]
        return commit

class GitHubContributionParser(ContributionParser):
    def __init__(self, project, args, token):
        super().__init__(project, args)
        self.client = GraphqlClient(endpoint="https://api.github.com/graphql")
        self.token = token

    def get_authored_contributions(self, author):
        commits = []
        has_next_page = True
        after_cursor = None
        emails_string = str(author.emails).replace('\'', '\"')

        query = f"""
        query {{
            repository(
                name: "{ self.project.repo['name'] }"
                owner: "{ self.project.repo['owner'] }"
            ) {{
                defaultBranchRef {{
                target {{
                    ... on Commit {{
                    history(
                        author: {{ emails: { emails_string } }}
                        after: { after_cursor if after_cursor else "null" }
                        since: "{ datetime.strptime(self.args.period_start, '%Y-%m-%d').isoformat() }"
                        until: "{ datetime.strptime(self.args.period_end, '%Y-%m-%d').isoformat() }"
                    ) {{
                        totalCount
                        pageInfo {{
                            hasNextPage
                            endCursor
                        }}
                        nodes {{
                        ... on Commit {{
                            oid
                            messageHeadline
                            committedDate
                            author {{
                                email
                            }}
                        }}
                        }}
                    }}
                    }}
                }}
                }}
            }}
        }}
        """

        while has_next_page:
            data = self.client.execute(
                query=query,
                headers={"Authorization": "Bearer {}".format(self.token)},
            )

            history = data["data"]["repository"]["defaultBranchRef"]["target"]["history"]

            for contribution in history["nodes"]:
                commit = {
                    "id": contribution["oid"],
                    "subject": contribution["messageHeadline"],
                    "date": contribution["committedDate"],
                    "author": author.name,
                    "email": contribution["author"]["email"]
                }
                commits.append(commit)

            has_next_page = history["pageInfo"]["hasNextPage"]
            after_cursor = history["pageInfo"]["endCursor"]

        for commit in commits:
            self.create_commit_link(commit)

        return commits

def dump_json(outfile, authors, projects, cfg, args):
    a = {
        author.name: {
            k: v
            for k, v in author.__dict__.items()
        } for author in authors
    }

    p = {
        project.name: {
            k: v
            for k, v in project.__dict__.items()
        } for project in projects
    }

    final = {
        'period': {
            'start': args.period_start,
            'end': args.period_end
        },
        'authors': a,
        'projects': p,
        'document': cfg['document']
    }

    # create folder
    out_path = os.path.dirname(outfile)
    if out_path and not os.path.exists(out_path):
        os.makedirs(out_path)

    with open(outfile, 'w') as f:
        json.dump(final, f, indent=2, separators=(',', ': '))
        f.write('\n')


def parse_args():
    start = datetime.now().replace(year=datetime.now().year-1)

    parser = argparse.ArgumentParser(description='Contribution reporter.')
    parser.add_argument('--from', dest='period_start', help='Period start',
                        default=start.strftime('%Y-%m-%d'))
    parser.add_argument('--to', dest='period_end', help='Period end',
                        default=datetime.now().strftime('%Y-%m-%d'))
    parser.add_argument('-p', '--project', dest='project', nargs='*',
                        help='project(s)')
    parser.add_argument('-c', '--config', dest='cfgfile', metavar='CFG',
                        type=str, help='config file', required=True)
    parser.add_argument('-o', '--out', dest='outfile', metavar='OUT',
                        type=str, help='output file', required=True)
    args = parser.parse_args()

    return args


def main():
    load_dotenv()
    authors = list()
    projects = list()

    args = parse_args()

    try:
        cfg = EnvYAML(args.cfgfile)
    except yaml.YAMLError as exc:
        print(exc)
        print('ERROR: parsing config')
        sys.exit(1)

    for name in cfg['authors']:
        authors.append(Author(name, cfg['authors'][name]))

    for name in cfg['projects']:
        projects.append(Project(name, cfg['projects'][name]))

    for project in projects:
        if args.project and project.name not in args.project:
            continue
        print('Checking project {}'.format(project.name))

        if project.parser == "git":
            parser = GitContributionParser(project, args)
        elif project.parser == "github":
            try:
                token = cfg['parser']['github']['token']
            except KeyError:
                print("Specifying parser.github.token in config is required for GitHub parser!")
                sys.exit(1)
            parser = GitHubContributionParser(project, args, token)
        else:
            print(f"Invalid parser { project.parser }")
            sys.exit(1)

        parser.update_project()

        for author in authors:
            print(' Author: {} .. '.format(author.name), end='', flush=True)
            if project.only_users and not author.name in project.only_users:
                print('skip')
                continue
            if project.skip_users and author.name in project.skip_users:
                print('skip')
                continue
            commits = parser.get_authored_contributions(author)
            if commits:
                author.add_authored_contributions(project.name, commits)

            others = parser.get_other_contributions(author)
            if others:
                author.add_other_contributions(project.name, others)

            if not (commits is None or others is None):
                print('{}/{}'.format(len(commits), len(others) if others else 0))

    dump_json(args.outfile, authors, projects, cfg, args)


if __name__ == '__main__':

    main()
